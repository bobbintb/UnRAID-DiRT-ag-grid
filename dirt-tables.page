Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link rel="stylesheet" type="text/css" href="/plugins/bobbintb.system.dirt/nodejs/frontend/css/dirt.css">

<div id="grid-wrapper" style="height: 100%; width: 100%;">
  <div id="myGrid" style="height: 100%; width: 100%;" class="ag-theme-balham"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@34.3.1/dist/ag-grid-enterprise.min.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/dirt-tables-helpers.js"></script>

<script>
  let socket;
  let gridApi;

  function connect() {
    socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tables.page`);

    socket.onopen = function() {
      console.log("WebSocket connection established.");
      socket.send(JSON.stringify({ action: 'findDuplicates' }));
    };

    socket.onmessage = function(event) {
      const message = JSON.parse(event.data);
      if (message.action === 'duplicateFiles') {
        const { duplicates, state, queue } = message.data;
        // Integrate the queue state into the duplicates data
        duplicates.forEach(masterRow => {
          masterRow.files.forEach(file => {
            // The queue stores actions against a single file path. A file might have multiple
            // paths (hard links), which are joined by <br> in the 'path' property.
            // We need to check if any of the file's paths are in the queue.
            const paths = file.path.split('<br>');
            for (const path of paths) {
              if (queue[path]) {
                file.action = queue[path];
                break; // Found the action, no need to check other paths
              }
            }
          });
        });
        initializeGrid(duplicates);
      } else if (message.action === 'removeFile') {
        if (!gridApi) return;
        const { ino } = message.data;
        gridApi.forEachNode(masterNode => {
          const fileToRemove = masterNode.data.files.find(file => file.ino === ino);
          if (fileToRemove) {
            const masterData = masterNode.data;
            if (masterData.files.length <= 2) {
              gridApi.applyTransaction({ remove: [masterData] });
            } else {
              masterData.files = masterData.files.filter(file => file.ino !== ino);
              masterData.count = masterData.files.length;
              masterData.totalSize = masterData.totalSize - fileToRemove.size;
              gridApi.applyTransaction({ update: [masterData] });
            }
          }
        });
      }
    };

    socket.onclose = function(event) {
      console.log("WebSocket connection closed. Reconnecting in 1 second...");
      setTimeout(function() {
        connect();
      }, 1000);
    };

    socket.onerror = function(error) {
      console.error("WebSocket error: ", error);
      socket.close();
    };
  }

  function initializeGrid(data) {
    function actionCellRenderer(params) {
      const eGui = document.createElement('div');
      eGui.innerHTML = `
        <button class="action-icon" data-action="delete"><i class="fa fa-trash"></i></button>
        <button class="action-icon" data-action="link"><i class="fa fa-link"></i></button>
      `;

      const buttons = eGui.querySelectorAll('.action-icon');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          if (params.data.is_original) {
            return; // Ignore clicks on the original (disabled) row
          }
          const action = button.dataset.action;
          const newAction = params.data.action === action ? null : action;

          // First, update the grid state locally for immediate feedback
          params.node.setDataValue('action', newAction);

          // Then, send the update to the backend to persist the state
          if (newAction) {
            // A file can have multiple paths (hard links). We only need to send one path
            // to the backend for it to be added to the action queue.
            const primaryPath = params.data.path.split('<br>')[0];
            socket.send(JSON.stringify({
              action: 'setFileAction',
              data: {
                ino: params.data.ino,
                path: primaryPath,
                action: newAction,
              },
            }));
          } else {
            socket.send(JSON.stringify({
              action: 'removeFileAction',
              data: {
                ino: params.data.ino,
              },
            }));
          }
        });
      });

      if (params.data.action) {
        const selectedButton = eGui.querySelector(`[data-action="${params.data.action}"]`);
        if (selectedButton) {
          selectedButton.classList.add('selected');
        }
      }

      return eGui;
    }

    class ActionHeaderComponent {
      init(params) {
        this.params = params;
        this.eGui = document.createElement('div');
        this.eGui.innerHTML = `
          <button class="action-icon" data-action="delete"><i class="fa fa-trash"></i></button>
          <button class="action-icon" data-action="link"><i class="fa fa-link"></i></button>
        `;

        this.updateHeaderState = this.updateHeaderState.bind(this);
        this.params.api.addEventListener('cellValueChanged', this.updateHeaderState);
        this.params.api.addEventListener('firstDataRendered', this.updateHeaderState);


        this.eGui.querySelectorAll('.action-icon').forEach(button => {
          button.addEventListener('click', () => {
            const action = button.dataset.action;
            const detailGridApi = this.params.api;

            let allSelected = true;
            let hasEligibleRows = false;
            detailGridApi.forEachNode(rowNode => {
              if (rowNode.data.is_original) return; // Skip the original row
              hasEligibleRows = true;
              if (rowNode.data.action !== action) {
                allSelected = false;
              }
            });

            // Toggle only if there's at least one eligible row
            const newAction = (allSelected && hasEligibleRows) ? null : action;

            if (hasEligibleRows) {
              detailGridApi.forEachNode(rowNode => {
                if (rowNode.data.is_original) return; // Skip the original row

                // Update local state for immediate feedback
                rowNode.setDataValue('action', newAction);

                // Persist the change to the backend
                const primaryPath = rowNode.data.path.split('<br>')[0];
                if (newAction) {
                  socket.send(JSON.stringify({
                    action: 'setFileAction',
                    data: {
                      ino: rowNode.data.ino,
                      path: primaryPath,
                      action: newAction,
                    },
                  }));
                } else {
                  socket.send(JSON.stringify({
                    action: 'removeFileAction',
                    data: {
                      ino: rowNode.data.ino,
                    },
                  }));
                }
              });
            }
          });
        });
      }

      updateHeaderState() {
        const detailGridApi = this.params.api;
        if (detailGridApi.getDisplayedRowCount() === 0) return;

        let firstAction = detailGridApi.getDisplayedRowAtIndex(0).data.action;
        let allSame = true;

        detailGridApi.forEachNode(rowNode => {
          if (rowNode.data.action !== firstAction) {
            allSame = false;
          }
        });

        const trashIcon = this.eGui.querySelector('[data-action="delete"]');
        const linkIcon = this.eGui.querySelector('[data-action="link"]');

        trashIcon.classList.remove('selected');
        linkIcon.classList.remove('selected');

        if (allSame && firstAction) {
          if (firstAction === 'delete') {
            trashIcon.classList.add('selected');
          } else if (firstAction === 'link') {
            linkIcon.classList.add('selected');
          }
        }
      }

      getGui() {
        return this.eGui;
      }

      destroy() {
        if (this.params && this.params.api) {
          this.params.api.removeEventListener('cellValueChanged', this.updateHeaderState);
          this.params.api.removeEventListener('firstDataRendered', this.updateHeaderState);
        }
      }
    }

    const gridOptions = {
      columnDefs: [
        { field: 'hash', headerName: 'Hash', cellRenderer: 'agGroupCellRenderer', width: 350 },
        { field: 'count', headerName: 'Count', width: 71 },
        {
          field: 'totalSize',
          headerName: 'Freeable',
          width: 90,
          valueFormatter: params => formatBytes(params.value)
        }
      ],
      rowData: data,
      onGridReady: (params) => {
        gridApi = params.api;
      },
      masterDetail: true,
      getRowId: params => params.data.hash,
      groupDefaultExpanded: -1,
      detailRowAutoHeight: true,
      defaultColDef: {
        suppressHeaderMenuButton: true,
        suppressHeaderContextMenu: true,
      },
      detailCellRendererParams: (masterParams) => {
        return {
          detailGridOptions: {
            components: {
              actionCellRenderer: actionCellRenderer,
              actionHeaderComponent: ActionHeaderComponent,
            },
            defaultColDef: {
              suppressHeaderMenuButton: true,
              suppressHeaderContextMenu: true,
            },
            getRowId: params => params.data.ino,
            rowClassRules: {
              'disabled-row': params => params.data.is_original,
            },
            columnDefs: [
              {
                headerName: '',
                width: 45,
                cellRenderer: (detailParams) => {
                  const input = document.createElement('input');
                  input.type = 'radio';
                  input.name = `radio-group-${masterParams.data.hash}`;
                  input.checked = detailParams.data.is_original;
                  input.addEventListener('change', () => {
                    if (input.checked) {
                      const newOriginalIno = detailParams.data.ino;
                      const detailGridApi = detailParams.api;

                      // Send the state update to the backend
                      socket.send(JSON.stringify({
                        action: 'setOriginalFile',
                        data: {
                          hash: masterParams.data.hash,
                          ino: newOriginalIno,
                        },
                      }));

                      // When a row is selected as the original, clear its action state
                      socket.send(JSON.stringify({
                        action: 'removeFileAction',
                        data: {
                          ino: newOriginalIno,
                        },
                      }));

                      // Update the grid state locally for immediate feedback
                      detailGridApi.forEachNode(node => {
                        const isNewOriginal = node.data.ino === newOriginalIno;
                        if (node.data.is_original !== isNewOriginal) {
                          node.setDataValue('is_original', isNewOriginal);
                        }
                        // Also clear the action in the local grid data
                        if (isNewOriginal) {
                          node.setDataValue('action', null);
                        }
                      });
                    }
                  });
                  return input;
                },
              },
              {
                headerName: '',
                field: 'action',
                width: 70,
                cellRenderer: 'actionCellRenderer',
                headerComponent: 'actionHeaderComponent',
              },
              { field: 'path', headerName: 'Path', flex: 1 },
              {
                field: 'size',
                headerName: 'Size',
                width: 85,
                valueFormatter: params => formatBytes(params.value)
              },
              {
                field: 'mtime',
                headerName: 'Modified',
                width: 185,
                valueFormatter: params => new Date(params.value).toLocaleString()
              },
              {
                field: 'ctime',
                headerName: 'Created',
                width: 185,
                valueFormatter: params => new Date(params.value).toLocaleString()
              }
            ]
          },
          getDetailRowData: (params) => {
            params.successCallback(params.data.files);
          },
        }
      }
    };

    const gridDiv = document.querySelector('#myGrid');
    agGrid.createGrid(gridDiv, gridOptions);
  }

  function setGridHeight() {
    const gridWrapper = document.querySelector('#grid-wrapper');
    const offsetTop = gridWrapper.offsetTop;
    const viewportHeight = window.innerHeight;
    const buffer = 30; // an arbitrary buffer
    gridWrapper.style.height = `${viewportHeight - offsetTop - buffer}px`;
  }

  document.addEventListener('DOMContentLoaded', function() {
    setGridHeight();
    window.addEventListener('resize', setGridHeight);
    connect();
  });
</script>
