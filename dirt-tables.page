Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="/plugins/bobbintb.system.dirt/nodejs/frontend/css/dirt.css">

<div id="grid-wrapper" style="height: 100%; width: 100%;">
  <div id="myGrid" style="height: 100%; width: 100%;" class="ag-theme-balham"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ag-grid-community@34.3.1/dist/ag-grid-community.min.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/dirt-tables-helpers.js"></script>

<script>
  let socket;
  let gridApi;

  function connect() {
    socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tables.page`);

    socket.onopen = function() {
      console.log("WebSocket connection established.");
      socket.send(JSON.stringify({ action: 'findDuplicates' }));
    };

    socket.onmessage = function(event) {
      const message = JSON.parse(event.data);
      if (message.action === 'duplicateFiles') {
        const { duplicates, state, queue } = message.data;
        initializeGrid(duplicates);
      } else if (message.action === 'removeFile') {
        if (!gridApi) return;
        const { ino } = message.data;
        gridApi.forEachNode(masterNode => {
          if (masterNode.data._type !== 'master') return;

          const fileToRemove = masterNode.data.files.find(file => file.ino === ino);
          if (fileToRemove) {
            const masterData = masterNode.data;
            if (masterData.files.length <= 2) {
              // Remove both master and detail rows
              const detailNodeId = masterData.hash + '_detail';
              const detailNode = gridApi.getRowNode(detailNodeId);
              const rowsToRemove = [masterData];
              if (detailNode) {
                rowsToRemove.push(detailNode.data);
              }
              gridApi.applyTransaction({ remove: rowsToRemove });
            } else {
              masterData.files = masterData.files.filter(file => file.ino !== ino);
              masterData.count = masterData.files.length;
              masterData.totalSize = masterData.totalSize - fileToRemove.size;

              // Update master row
              gridApi.applyTransaction({ update: [masterData] });

              // Update detail row data for sorting and height
              const detailNodeId = masterData.hash + '_detail';
              const detailNode = gridApi.getRowNode(detailNodeId);
              if (detailNode) {
                 const detailData = detailNode.data;
                 // Sync sortable fields
                 detailData.count = masterData.count;
                 detailData.totalSize = masterData.totalSize;
                 gridApi.applyTransaction({ update: [detailData] });

                 gridApi.refreshCells({ rowNodes: [detailNode], force: true });
                 gridApi.resetRowHeights();
              }
            }
          }
        });
      }
    };

    socket.onclose = function(event) {
      console.log("WebSocket connection closed. Reconnecting in 1 second...");
      setTimeout(function() {
        connect();
      }, 1000);
    };

    socket.onerror = function(error) {
      console.error("WebSocket error: ", error);
      socket.close();
    };
  }

  function initializeGrid(data) {
    const collapsedGroups = new Set();

    function GroupCellRenderer(params) {
      const eGui = document.createElement('div');
      eGui.style.display = 'flex';
      eGui.style.alignItems = 'center';

      const hash = params.value;
      // Default is expanded (not in set).
      // If in set -> collapsed (right chevron).
      // If not in set -> expanded (down chevron).
      const isCollapsed = collapsedGroups.has(hash);
      const iconClass = isCollapsed ? 'fa-chevron-right' : 'fa-chevron-down';

      eGui.innerHTML = `
        <i class="fa ${iconClass}" style="cursor: pointer; margin-right: 8px; width: 12px;"></i>
        <span>${hash}</span>
      `;

      const icon = eGui.querySelector('i');
      icon.addEventListener('click', (e) => {
        e.stopPropagation();
        if (collapsedGroups.has(hash)) {
          collapsedGroups.delete(hash);
          icon.className = 'fa fa-chevron-down';
        } else {
          collapsedGroups.add(hash);
          icon.className = 'fa fa-chevron-right';
        }
        params.api.onFilterChanged();
      });

      return eGui;
    }

    function actionCellRenderer(params) {
      const eGui = document.createElement('div');
      eGui.innerHTML = `
        <button class="action-icon" data-action="delete"><i class="fa fa-trash"></i></button>
        <button class="action-icon" data-action="link"><i class="fa fa-link"></i></button>
      `;

      const buttons = eGui.querySelectorAll('.action-icon');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          const action = button.dataset.action;
          const newAction = params.data.action === action ? null : action;
          params.node.setDataValue('action', newAction);
        });
      });

      if (params.data.action) {
        const selectedButton = eGui.querySelector(`[data-action="${params.data.action}"]`);
        if (selectedButton) {
          selectedButton.classList.add('selected');
        }
      }

      return eGui;
    }

    class ActionHeaderComponent {
      init(params) {
        this.params = params;
        this.eGui = document.createElement('div');
        this.eGui.innerHTML = `
          <button class="action-icon" data-action="delete"><i class="fa fa-trash"></i></button>
          <button class="action-icon" data-action="link"><i class="fa fa-link"></i></button>
        `;

        this.updateHeaderState = this.updateHeaderState.bind(this);
        this.params.api.addEventListener('cellValueChanged', this.updateHeaderState);
        this.params.api.addEventListener('firstDataRendered', this.updateHeaderState);


        this.eGui.querySelectorAll('.action-icon').forEach(button => {
          button.addEventListener('click', () => {
            const action = button.dataset.action;
            const detailGridApi = this.params.api;

            let allSelected = true;
            detailGridApi.forEachNode(rowNode => {
              if (rowNode.data.action !== action) {
                allSelected = false;
              }
            });

            const newAction = allSelected ? null : action;

            detailGridApi.forEachNode(rowNode => {
              rowNode.setDataValue('action', newAction);
            });
          });
        });
      }

      updateHeaderState() {
        const detailGridApi = this.params.api;
        if (detailGridApi.getDisplayedRowCount() === 0) return;

        let firstAction = detailGridApi.getDisplayedRowAtIndex(0).data.action;
        let allSame = true;

        detailGridApi.forEachNode(rowNode => {
          if (rowNode.data.action !== firstAction) {
            allSame = false;
          }
        });

        const trashIcon = this.eGui.querySelector('[data-action="delete"]');
        const linkIcon = this.eGui.querySelector('[data-action="link"]');

        trashIcon.classList.remove('selected');
        linkIcon.classList.remove('selected');

        if (allSame && firstAction) {
          if (firstAction === 'delete') {
            trashIcon.classList.add('selected');
          } else if (firstAction === 'link') {
            linkIcon.classList.add('selected');
          }
        }
      }

      getGui() {
        return this.eGui;
      }

      destroy() {
        if (this.params && this.params.api) {
          this.params.api.removeEventListener('cellValueChanged', this.updateHeaderState);
          this.params.api.removeEventListener('firstDataRendered', this.updateHeaderState);
        }
      }
    }

    class DetailCellRenderer {
      init(params) {
        this.eGui = document.createElement('div');
        this.eGui.style.width = '100%';
        this.eGui.style.height = '100%';
        // Add a wrapper for padding if needed, matching standard detail row
        this.eGui.style.padding = '20px';
        this.eGui.style.boxSizing = 'border-box';

        // Inner container for the grid
        const gridContainer = document.createElement('div');
        gridContainer.style.width = '100%';
        gridContainer.style.height = '100%';
        gridContainer.className = 'ag-theme-balham ag-details-grid'; // Add class for styling/testing
        this.eGui.appendChild(gridContainer);

        const masterHash = params.data.parent.hash;

        const detailGridOptions = {
          rowData: params.data.parent.files,
          domLayout: 'autoHeight',
          components: {
            actionCellRenderer: actionCellRenderer,
            actionHeaderComponent: ActionHeaderComponent,
          },
          defaultColDef: {
            suppressHeaderMenuButton: true,
            suppressHeaderContextMenu: true,
          },
          getRowId: params => params.data.ino,
          columnDefs: [
            {
              headerName: '',
              width: 45,
              cellRenderer: (detailParams) => {
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = `radio-group-${masterHash}`;
                input.checked = detailParams.data.is_original;
                input.addEventListener('change', () => {
                  if (input.checked) {
                    socket.send(JSON.stringify({
                      action: 'setOriginalFile',
                      data: {
                        hash: masterHash,
                        ino: detailParams.data.ino,
                      },
                    }));
                  }
                });
                return input;
              },
            },
            {
              headerName: '',
              field: 'action',
              width: 70,
              cellRenderer: 'actionCellRenderer',
              headerComponent: 'actionHeaderComponent',
            },
            { field: 'path', headerName: 'Path', flex: 1 },
            {
              field: 'size',
              headerName: 'Size',
              width: 85,
              valueFormatter: params => formatBytes(params.value)
            },
            {
              field: 'mtime',
              headerName: 'Modified',
              width: 185,
              valueFormatter: params => new Date(params.value).toLocaleString()
            },
            {
              field: 'ctime',
              headerName: 'Created',
              width: 185,
              valueFormatter: params => new Date(params.value).toLocaleString()
            }
          ]
        };

        this.detailGridApi = agGrid.createGrid(gridContainer, detailGridOptions).api;
      }

      getGui() {
        return this.eGui;
      }

      refresh(params) {
        if (this.detailGridApi) {
          this.detailGridApi.setGridOption('rowData', params.data.parent.files);
          return true;
        }
        return false;
      }

      destroy() {
        if (this.detailGridApi) {
           this.detailGridApi.destroy();
        }
      }
    }

    const customComparator = (valueA, valueB, nodeA, nodeB, isDescending) => {
      if (valueA == valueB) {
        // Both Master and Detail now have 'hash' property
        const hashA = nodeA.data.hash;
        const hashB = nodeB.data.hash;
        if (hashA === hashB) {
          // Same group. We want Master first.
          const aIsMaster = nodeA.data._type === 'master';
          // If A is Master, we want -1 (A < B).
          // If Descending, grid flips result. So we return 1 (so grid flips to -1).
          // If Ascending, we return -1.
          const res = aIsMaster ? -1 : 1;
          return isDescending ? -res : res;
        }
        // Sort by hash to keep groups distinct and deterministic
        return String(hashA).localeCompare(String(hashB));
      }
      if (typeof valueA === 'string') {
         return valueA.localeCompare(valueB);
      }
      return valueA - valueB;
    };

    // Flatten data for Master/Detail simulation
    const rowData = [];
    data.forEach(group => {
      const masterRow = { ...group, _type: 'master' };
      if (!masterRow.count) masterRow.count = masterRow.files ? masterRow.files.length : 0;

      rowData.push(masterRow);
      // Copy sortable fields to detail row so sorting works natively
      rowData.push({
          _type: 'detail',
          parent: masterRow,
          hash: masterRow.hash,
          count: masterRow.count,
          totalSize: masterRow.totalSize
      });
    });

    const gridOptions = {
      columnDefs: [
        {
          field: 'hash',
          headerName: 'Hash',
          width: 350,
          comparator: customComparator,
          cellRenderer: GroupCellRenderer
        },
        {
          field: 'count',
          headerName: 'Count',
          width: 71,
          comparator: customComparator
        },
        {
          field: 'totalSize',
          headerName: 'Freeable',
          width: 90,
          valueFormatter: params => formatBytes(params.value),
          comparator: customComparator
        }
      ],
      rowData: rowData,
      onGridReady: (params) => {
        gridApi = params.api;
      },
      getRowId: params => {
        if (params.data._type === 'detail') {
          return params.data.parent.hash + '_detail';
        }
        return params.data.hash;
      },
      isFullWidthRow: (params) => params.rowNode.data._type === 'detail',
      fullWidthCellRenderer: DetailCellRenderer,
      getRowHeight: (params) => {
        if (params.node.data._type === 'detail') {
          const files = params.data.parent.files;
          const count = files ? files.length : 0;
          // 28px per row + 33px header + 40px padding + extra buffer for borders/scrollbars
          return (count * 28) + 33 + 60;
        }
        return 28; // Default master row height
      },
      isExternalFilterPresent: () => collapsedGroups.size > 0,
      doesExternalFilterPass: (node) => {
        if (node.data._type === 'detail') {
           return !collapsedGroups.has(node.data.parent.hash);
        }
        return true;
      },
      defaultColDef: {
        suppressHeaderMenuButton: true,
        suppressHeaderContextMenu: true,
      },
    };

    const gridDiv = document.querySelector('#myGrid');
    agGrid.createGrid(gridDiv, gridOptions);
  }

  function setGridHeight() {
    const gridWrapper = document.querySelector('#grid-wrapper');
    const offsetTop = gridWrapper.offsetTop;
    const viewportHeight = window.innerHeight;
    const buffer = 30; // an arbitrary buffer
    gridWrapper.style.height = `${viewportHeight - offsetTop - buffer}px`;
  }

  document.addEventListener('DOMContentLoaded', function() {
    setGridHeight();
    window.addEventListener('resize', setGridHeight);
    connect();
  });
</script>
